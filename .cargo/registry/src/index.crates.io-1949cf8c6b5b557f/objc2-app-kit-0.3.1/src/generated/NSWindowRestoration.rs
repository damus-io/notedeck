//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nswindowrestoration?language=objc)
    pub unsafe trait NSWindowRestoration: NSObjectProtocol + MainThreadOnly {
        #[cfg(all(
            feature = "NSResponder",
            feature = "NSUserInterfaceItemIdentification",
            feature = "NSWindow",
            feature = "block2"
        ))]
        #[unsafe(method(restoreWindowWithIdentifier:state:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn restoreWindowWithIdentifier_state_completionHandler(
            identifier: &NSUserInterfaceItemIdentifier,
            state: &NSCoder,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSWindow, *mut NSError)>,
            mtm: MainThreadMarker,
        );
    }
);

/// NSWindowRestoration.
#[cfg(feature = "NSDocumentController")]
impl NSDocumentController {
    extern_methods!();
}

#[cfg(feature = "NSDocumentController")]
extern_conformance!(
    unsafe impl NSWindowRestoration for NSDocumentController {}
);

/// NSWindowRestoration.
#[cfg(all(feature = "NSApplication", feature = "NSResponder"))]
impl NSApplication {
    extern_methods!(
        #[cfg(all(
            feature = "NSUserInterfaceItemIdentification",
            feature = "NSWindow",
            feature = "block2"
        ))]
        #[unsafe(method(restoreWindowWithIdentifier:state:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn restoreWindowWithIdentifier_state_completionHandler(
            &self,
            identifier: &NSUserInterfaceItemIdentifier,
            state: &NSCoder,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSWindow, *mut NSError)>,
        ) -> bool;
    );
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/appkit/nsapplicationdidfinishrestoringwindowsnotification?language=objc)
    pub static NSApplicationDidFinishRestoringWindowsNotification: &'static NSNotificationName;
}

/// NSUserInterfaceRestoration.
#[cfg(all(feature = "NSResponder", feature = "NSWindow"))]
impl NSWindow {
    extern_methods!(
        #[unsafe(method(isRestorable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isRestorable(&self) -> bool;

        /// Setter for [`isRestorable`][Self::isRestorable].
        #[unsafe(method(setRestorable:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRestorable(&self, restorable: bool);

        #[unsafe(method(restorationClass))]
        #[unsafe(method_family = none)]
        pub unsafe fn restorationClass(&self) -> Option<&'static AnyClass>;

        /// Setter for [`restorationClass`][Self::restorationClass].
        #[unsafe(method(setRestorationClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRestorationClass(&self, restoration_class: Option<&AnyClass>);

        #[unsafe(method(disableSnapshotRestoration))]
        #[unsafe(method_family = none)]
        pub unsafe fn disableSnapshotRestoration(&self);

        #[unsafe(method(enableSnapshotRestoration))]
        #[unsafe(method_family = none)]
        pub unsafe fn enableSnapshotRestoration(&self);
    );
}

/// NSRestorableState.
#[cfg(feature = "NSResponder")]
impl NSResponder {
    extern_methods!(
        #[unsafe(method(encodeRestorableStateWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeRestorableStateWithCoder(&self, coder: &NSCoder);

        #[unsafe(method(encodeRestorableStateWithCoder:backgroundQueue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeRestorableStateWithCoder_backgroundQueue(
            &self,
            coder: &NSCoder,
            queue: &NSOperationQueue,
        );

        #[unsafe(method(restoreStateWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn restoreStateWithCoder(&self, coder: &NSCoder);

        #[unsafe(method(invalidateRestorableState))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidateRestorableState(&self);

        #[unsafe(method(restorableStateKeyPaths))]
        #[unsafe(method_family = none)]
        pub unsafe fn restorableStateKeyPaths(mtm: MainThreadMarker)
            -> Retained<NSArray<NSString>>;

        /// When secure state restoration is used, values at restorableStateKeyPaths must support NSSecureCoding and this method will be consulted when restoring state. Any values not of an allowed class will not be set.
        #[unsafe(method(allowedClassesForRestorableStateKeyPath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowedClassesForRestorableStateKeyPath(
            key_path: &NSString,
            mtm: MainThreadMarker,
        ) -> Retained<NSArray<AnyClass>>;
    );
}

/// NSRestorableStateExtension.
#[cfg(all(feature = "NSApplication", feature = "NSResponder"))]
impl NSApplication {
    extern_methods!(
        #[unsafe(method(extendStateRestoration))]
        #[unsafe(method_family = none)]
        pub unsafe fn extendStateRestoration(&self);

        #[unsafe(method(completeStateRestoration))]
        #[unsafe(method_family = none)]
        pub unsafe fn completeStateRestoration(&self);
    );
}

/// NSRestorableState.
#[cfg(feature = "NSDocument")]
impl NSDocument {
    extern_methods!(
        #[cfg(all(
            feature = "NSResponder",
            feature = "NSUserInterfaceItemIdentification",
            feature = "NSWindow",
            feature = "block2"
        ))]
        #[unsafe(method(restoreDocumentWindowWithIdentifier:state:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn restoreDocumentWindowWithIdentifier_state_completionHandler(
            &self,
            identifier: &NSUserInterfaceItemIdentifier,
            state: &NSCoder,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSWindow, *mut NSError)>,
        );

        #[unsafe(method(encodeRestorableStateWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeRestorableStateWithCoder(&self, coder: &NSCoder);

        #[unsafe(method(encodeRestorableStateWithCoder:backgroundQueue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeRestorableStateWithCoder_backgroundQueue(
            &self,
            coder: &NSCoder,
            queue: &NSOperationQueue,
        );

        #[unsafe(method(restoreStateWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn restoreStateWithCoder(&self, coder: &NSCoder);

        #[unsafe(method(invalidateRestorableState))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidateRestorableState(&self);

        #[unsafe(method(restorableStateKeyPaths))]
        #[unsafe(method_family = none)]
        pub unsafe fn restorableStateKeyPaths(mtm: MainThreadMarker)
            -> Retained<NSArray<NSString>>;

        #[unsafe(method(allowedClassesForRestorableStateKeyPath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowedClassesForRestorableStateKeyPath(
            key_path: &NSString,
            mtm: MainThreadMarker,
        ) -> Retained<NSArray<AnyClass>>;
    );
}
