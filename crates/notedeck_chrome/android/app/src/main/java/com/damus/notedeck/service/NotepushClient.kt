package com.damus.notedeck.service

import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.HttpUrl.Companion.toHttpUrl
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import java.util.concurrent.TimeUnit

/**
 * HTTP client for communicating with the notepush server.
 *
 * All requests are authenticated using NIP-98 (Nostr HTTP Auth).
 * The auth header is generated by signing a kind 27235 event in Rust.
 */
class NotepushClient(
    private val baseUrl: String = "https://notepush.damus.io"
) {
    companion object {
        private const val TAG = "NotepushClient"
        private val JSON_MEDIA_TYPE = "application/json; charset=utf-8".toMediaType()
    }

    private val client = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .writeTimeout(30, TimeUnit.SECONDS)
        .build()

    /**
     * Builds a properly URL-encoded path for the notepush API.
     * Uses HttpUrl.Builder to safely encode path segments.
     */
    private fun buildUrl(
        pubkeyHex: String,
        fcmToken: String,
        suffix: String? = null,
        backend: String? = null
    ): String {
        val builder = baseUrl.toHttpUrl().newBuilder()
            .addPathSegment("user-info")
            .addPathSegment(pubkeyHex)
            .addPathSegment(fcmToken)

        suffix?.let { builder.addPathSegment(it) }
        backend?.let { builder.addQueryParameter("backend", it) }

        return builder.build().toString()
    }

    /**
     * Register a device token with the notepush server for FCM notifications.
     *
     * @param pubkeyHex The user's public key in hex format
     * @param fcmToken The FCM device token
     * @return true if registration succeeded
     */
    suspend fun registerDevice(pubkeyHex: String, fcmToken: String): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val url = buildUrl(pubkeyHex, fcmToken, backend = "fcm")
                val authHeader = nativeSignNip98Auth(url, "PUT", null)

                if (authHeader == null) {
                    Log.e(TAG, "Failed to sign NIP-98 auth")
                    return@withContext false
                }

                val request = Request.Builder()
                    .url(url)
                    .put("".toRequestBody(JSON_MEDIA_TYPE))
                    .addHeader("Authorization", "Nostr $authHeader")
                    .build()

                client.newCall(request).execute().use { response ->
                    if (!response.isSuccessful) {
                        Log.e(TAG, "Register failed: ${response.code} ${response.body?.string()}")
                    } else {
                        Log.d(TAG, "Device registered successfully")
                    }
                    response.isSuccessful
                }
            } catch (e: Exception) {
                Log.e(TAG, "Register error", e)
                false
            }
        }
    }

    /**
     * Unregister a device token from the notepush server.
     *
     * @param pubkeyHex The user's public key in hex format
     * @param fcmToken The FCM device token
     * @return true if unregistration succeeded
     */
    suspend fun unregisterDevice(pubkeyHex: String, fcmToken: String): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val url = buildUrl(pubkeyHex, fcmToken)
                val authHeader = nativeSignNip98Auth(url, "DELETE", null)

                if (authHeader == null) {
                    Log.e(TAG, "Failed to sign NIP-98 auth")
                    return@withContext false
                }

                val request = Request.Builder()
                    .url(url)
                    .delete()
                    .addHeader("Authorization", "Nostr $authHeader")
                    .build()

                client.newCall(request).execute().use { response ->
                    if (!response.isSuccessful) {
                        Log.e(TAG, "Unregister failed: ${response.code} ${response.body?.string()}")
                    } else {
                        Log.d(TAG, "Device unregistered successfully")
                    }
                    response.isSuccessful
                }
            } catch (e: Exception) {
                Log.e(TAG, "Unregister error", e)
                false
            }
        }
    }

    /**
     * Get notification preferences for a device.
     *
     * @param pubkeyHex The user's public key in hex format
     * @param fcmToken The FCM device token
     * @return JSON string of preferences, or null on error
     */
    suspend fun getPreferences(pubkeyHex: String, fcmToken: String): String? {
        return withContext(Dispatchers.IO) {
            try {
                val url = buildUrl(pubkeyHex, fcmToken, suffix = "preferences")
                val authHeader = nativeSignNip98Auth(url, "GET", null)

                if (authHeader == null) {
                    Log.e(TAG, "Failed to sign NIP-98 auth")
                    return@withContext null
                }

                val request = Request.Builder()
                    .url(url)
                    .get()
                    .addHeader("Authorization", "Nostr $authHeader")
                    .build()

                client.newCall(request).execute().use { response ->
                    if (response.isSuccessful) {
                        response.body?.string()
                    } else {
                        Log.e(TAG, "Get preferences failed: ${response.code}")
                        null
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Get preferences error", e)
                null
            }
        }
    }

    /**
     * Update notification preferences for a device.
     *
     * @param pubkeyHex The user's public key in hex format
     * @param fcmToken The FCM device token
     * @param preferencesJson JSON string of preferences
     * @return true if update succeeded
     */
    suspend fun setPreferences(pubkeyHex: String, fcmToken: String, preferencesJson: String): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val url = buildUrl(pubkeyHex, fcmToken, suffix = "preferences")
                val authHeader = nativeSignNip98Auth(url, "PUT", preferencesJson)

                if (authHeader == null) {
                    Log.e(TAG, "Failed to sign NIP-98 auth")
                    return@withContext false
                }

                val request = Request.Builder()
                    .url(url)
                    .put(preferencesJson.toRequestBody(JSON_MEDIA_TYPE))
                    .addHeader("Authorization", "Nostr $authHeader")
                    .build()

                client.newCall(request).execute().use { response ->
                    if (!response.isSuccessful) {
                        Log.e(TAG, "Set preferences failed: ${response.code} ${response.body?.string()}")
                    } else {
                        Log.d(TAG, "Preferences updated successfully")
                    }
                    response.isSuccessful
                }
            } catch (e: Exception) {
                Log.e(TAG, "Set preferences error", e)
                false
            }
        }
    }

    /**
     * Signs a NIP-98 HTTP Auth event for API authentication.
     *
     * Implemented in Rust (android.rs). Creates a kind 27235 Nostr event
     * signed with the active account's keypair.
     *
     * @param url The full request URL (included in the 'u' tag)
     * @param method HTTP method: GET, POST, PUT, DELETE
     * @param body Request body for payload hash (optional, used in 'payload' tag)
     * @return Base64-encoded signed event JSON, or null if signing fails
     */
    private external fun nativeSignNip98Auth(url: String, method: String, body: String?): String?

    init {
        System.loadLibrary("notedeck_chrome")
    }
}
